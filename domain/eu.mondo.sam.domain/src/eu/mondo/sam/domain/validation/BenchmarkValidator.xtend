/*
 * generated by Xtext
 */
package eu.mondo.sam.domain.validation

import org.eclipse.xtext.validation.Check
import eu.mondo.sam.domain.benchmark.AtomicPhase
import eu.mondo.sam.domain.benchmark.BenchmarkPackage
import eu.mondo.sam.domain.benchmark.IterationPhase
import eu.mondo.sam.domain.benchmark.SequencePhase
import eu.mondo.sam.domain.benchmark.OptionalPhase
import eu.mondo.sam.domain.benchmark.NewMetric
import eu.mondo.sam.domain.benchmark.Scenario
import eu.mondo.sam.domain.benchmark.Phase
import eu.mondo.sam.domain.benchmark.PhaseReference
import eu.mondo.sam.domain.benchmark.NewPhase
import eu.mondo.sam.domain.benchmark.Element
import eu.mondo.sam.domain.benchmark.Benchmark
import java.util.Set
import java.util.HashSet
import eu.mondo.sam.domain.benchmark.AttachedPhase
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.EObject

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class BenchmarkValidator extends AbstractBenchmarkValidator {

	

	@Check
	def checkAtomicPhaseStartsWithCapital(AtomicPhase atomic) {
		if (atomic.classname == null){
			return
		}
		if (atomic.classname.length == 0){
			return
		}
		if (!Character.isUpperCase(atomic.classname.charAt(0))) {
			warning('The name of the phase should start with capital since it represents a class name.', 
				BenchmarkPackage.Literals.ATOMIC_PHASE__CLASSNAME, "invalid_atomicphase")
		}
	}
	
	
	@Check
	def checkOptionalPhaseStartsWithCapital(OptionalPhase optional) {
		if (optional.classname == null){
			return
		}
		if (optional.classname.length == 0){
			return
		}
		if (!Character.isUpperCase(optional.classname.charAt(0))) {
			warning('The name of the phase should start with capital since it represents a class name.', 
				BenchmarkPackage.Literals.OPTIONAL_PHASE__CLASSNAME, "invalid_optionalphase")
		}
	}
	
	@Check
	def checkMetricStartsWithCapital(NewMetric metric) {
		if (!Character.isUpperCase(metric.classname.charAt(0))) {
			warning('The name of the metric should start with capital since it represents a new class name.', 
				BenchmarkPackage.Literals.NEW_METRIC__CLASSNAME, "invalid_metric"
			)
		}
	}
	
	@Check
	def checkScenarioStartsWithCapital(Scenario scenario) {
		if (!Character.isUpperCase(scenario.classname.charAt(0))) {
			warning('The name of the scenario should start with capital since it represents a new class name.', 
				BenchmarkPackage.Literals.SCENARIO__CLASSNAME, "invalid_scenario" 
			)
		}
	}
	
	@Check
	def checkIterationPhaseCounter(IterationPhase iteration){
		if (iteration.iteration < 1){
			error('The iteration must be higher than 0',
				BenchmarkPackage.Literals.ITERATION_PHASE__ITERATION, "invalid_iteration"
			)
		}
	}
	
	@Check
	def checkUniqueClassNames(Scenario scenario){
		val allElements = (scenario.eContainer as Benchmark).elements
		if (allElements == null){
			return
		}
		val  List<String> classNames = new ArrayList<String>
		for (e : allElements){
			if (e instanceof Scenario){
				classNames.add(e.classname)
			}
			if (e instanceof AtomicPhase){
				classNames.add(e.classname)
			}
			if (e instanceof OptionalPhase){
				classNames.add(e.classname)
			}
			ClassNameResolver::resolve(e, classNames, e)
		}
		var match = 0
		for (i : classNames){
			for(j : classNames){
				if (i.equals(j)){
					match++
				}
			}
			if (match > 1){
				error("The class names of scenarios and phases must be unique",
						BenchmarkPackage.Literals.SCENARIO__CLASSNAME, "not_unique_scenario"
					)
				return
			}
			match = 0
		}
}

	@Check
	def checkCycle(Scenario scenario){
		if (scenario.rootPhase == null){
			return
		}
		val Set<EObject> phases = new HashSet<EObject>
		if (CircleResolver::resolve(scenario.rootPhase, phases)){
			error("There is a circular reference in the structure of phases.",
						BenchmarkPackage.Literals.SCENARIO__CLASSNAME, "circle_in_scenario"
					)
		}
		
	}

}
